// From the paper with Tom (firstversion.pdf):
// - total of N individuals
// - time is sped up by theta (-> infinity)
// - nearly critical: mean net number of offspring scaling like 1/theta
// - dispersal scaling to be Gaussian, so if dispersal distance is SD,
//     need theta * SD^2 of order 1, ie, SD ~ 1/sqrt(theta)
// - to get deterministic, need theta/N -> 0
// - to get superprocess, need theta/N -> rho > 0
//    and so we need the deviation of mortality from fecundity needs to be divided by theta
//
// So: we will set
// - W = 20
// - density theta/rho = K so N = K * W^2 = theta/rho * 400
// - dispersal distance = SD = 1/sqrt(theta)
// - interaction distance = SI * SD
// - Note that the neighborhood size is SD^2 * K = 1/rho
// - NUMGENS = theta * 10
//
// So:
// - theta = 1/SD^2
// - rho = 1/neighborhood size = 1/(SD^2 * K)

initialize() {
    initializeSLiMModelType("nonWF");
    initializeSLiMOptions(dimensionality="xy", periodicity="xy");
    initializeTreeSeq();

    if (!exists("seed")) {
      seed = getSeed();
    }
    if (!exists("NUMGENS")) {
      defineConstant("NUMGENS", 30);
    }
    if (!exists("OUTPATH")) {
      defineConstant("OUTPATH", "test_torus." + NUMGENS + "." + seed + ".trees");
    }
    if (!exists("RHO")) { // 1/neighborhood size
      defineConstant("RHO", 1.0);
    }
    if (!exists("THETA")) { // 1/SD^2
      defineConstant("THETA", 1.0);
    }
    if (!exists("REL_SI")) { // relative interaction distance
      defineConstant("REL_SI", 1.0);
    }
    if (!exists("BURNIN")) {
      defineConstant("BURNIN", 200);  // number of generations before full recording begins
    }

    catn(c("NUMGENS =", NUMGENS));
    catn(c("BURNIN =", BURNIN));
    catn(c("RHO =", RHO));
    catn(c("THETA =", THETA));
    defineConstant("K", THETA/RHO);
    catn(c("K =", K));
    defineConstant("W", 20.0);  // width of the simulated area
    catn(c("W =", W));
    defineConstant("A", 1.0);  // height/width of the simulated area
    catn(c("A =", A));
    defineConstant("SD", 1.0/sqrt(THETA));  // dispersal distance
    catn(c("SD =", SD));
    catn(c("REL_SI =", REL_SI));
    defineConstant("SI", REL_SI * SD); // interaction distance
    catn(c("SI =", SI));
    defineConstant("SM", SI);
    catn(c("SM =", SM));
    defineConstant("L", 4);    // mean lifetime at stationarity
    catn(c("L =", L));
    defineConstant("G", 2e9);  // genome length
    catn(c("G =", G));
    defineConstant("FECUN", 1/L); // mean fecundity
    catn(c("FECUN =", FECUN));
    defineConstant("CONST", FECUN/((1+FECUN) * K)); // constant in spatial competition function

    initializeMutationType("m1", 0.5, "g", 0.0, 2);
    initializeGenomicElementType("g1", m1, 1.0);
    initializeGenomicElement(g1, 0, G-1);
    initializeMutationRate(0.0);
    initializeRecombinationRate(1e-9);

    // mate choice
    initializeInteractionType(1, "xy", reciprocal=T, maxDistance=min(W*0.49, SM * 6));
    i1.setInteractionFunction("n", 1.0/(2*PI*SM^2), SM);
    // spatial mortality effects
    initializeInteractionType(2, "xy", reciprocal=T, maxDistance=min(W*0.49, SI * 3));
    i2.setInteractionFunction("n", 1.0/(2*PI*SI^2), SI);
}

reproduction() {
    // choose a neighbor as a mate
    mate = i1.drawByStrength(individual, 1);
    if (mate.size()) {
        nOff = rpois(1, FECUN);
        // record number of offspring in the tag
        individual.tag = individual.tag + nOff;
        for (i in seqLen(nOff)) {
            pos = individual.spatialPosition + rnorm(2, 0, SD);
            if (p1.pointInBounds(pos)) {
              offspring = subpop.addCrossed(individual, mate);
              offspring.setSpatialPosition(p1.pointReflected(pos));
              offspring.tag = 0;
            }
        }
    } else {
       catn("couldn't find a mate!!");
    }
    return;
}

1 early() {
    sim.addSubpop("p1", asInteger(K * A * W * W));
    p1.setSpatialBounds(c(0, 0, W, A * W));
    // random initial positions
    for (ind in p1.individuals) {
        ind.setSpatialPosition(p1.pointUniform());
        ind.tag = 0;
    }
    i1.evaluate(sim.subpopulations);
    
    // header info
    cat("gen" + " " + "stage" + " ");
    cat("pop_size" + " " + "births" + " ");
    cat("age" + " " + "density" + " ");
    catn("neighbor" + " " + "harm_neigh" + " " + "num_off" + " " + "time");
}

early() {
    i2.evaluate(p1);
    inds = p1.individuals;
    competition = i2.totalOfNeighborStrengths(inds);
    // record strength of competition in the tagF
    inds.tagF = competition;
    inds.fitnessScaling = pmin(1.0, (1 - FECUN * (1 - (1/THETA) * (1 - competition / K))));
}

(BURNIN+1):(BURNIN+NUMGENS) early() {
    // remember everyone
    sim.treeSeqRememberIndividuals(p1.individuals);
}

1: late() {
   // to be ready for mate choice
   i1.evaluate(p1);
}

// output
early() {
    if (T) {
        cat(sim.cycle + " " + "early" + " ");
        cat(p1.individualCount + " " + sum(p1.individuals.age == 0) + " ");
        cat(mean(p1.individuals.age) + " " + p1.individualCount/(A * W * W) + " ");
        cat(mean(p1.individuals.tagF) + " " + 1/mean(1/p1.individuals.tagF) + " " + mean(p1.individuals.tag));
        catn(" " + clock());
    }
}

late() {
    if (T) {
        cat(sim.cycle + " " + "late " + " ");
        cat(p1.individualCount + " " + sum(p1.individuals.age == 0) + " ");
        cat(mean(p1.individuals.age) + " " + p1.individualCount/(A * W * W) + " ");
        cat(mean(p1.individuals.tagF) + " " + 1/mean(1/p1.individuals.tagF) + " " + mean(p1.individuals.tag));
        catn(" " + clock());
    }
}

2: late() {
    // GUI COLORS
    //  green = many neighbors, few offspring so far
    //  red = many offspring so far, few neighbors
    //  yellow = many offspring so far, many neighbors
    max_n = max(1, max(p1.individuals.tag));
    max_f = max(0.01, max(p1.individuals.tagF));
    max_a = max(p1.individuals.age);
    for (ind in p1.individuals) {
       ind.color = rgb2color(c(ind.tag/max_n, ind.tagF/max_f, ind.age/max_a));
    }
}

BURNIN+NUMGENS late() {
   sim.treeSeqOutput(OUTPATH, simplify=F);
   sim.simulationFinished();
}
